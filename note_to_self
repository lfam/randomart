segfault if only input is newline :(

----

Okay, here's whats happening:
randomart.c processes input two chars a time. With well-formed input, each two
chars are converted to a hex byte, and the final, odd byte is the newline. (This
works because getline() returns the length of the input minus the null
terminator.) When we pass the input and (input_len - 1) to
fingerprint_randomart, we never iterate over the character at input[input_len], so
the newline is not processed. But if the input is malformed, and the newline is
not in an odd position, it does get processed, and thus placed on *errstring.

Well formed example input:
'a', 'b', '\n', '\0'
           ^
           Not processed when reading two at a time for (len - 1) / 2

Malformed example input:
'a', 'b', 'a', '\n', '\0'
                ^
                Processed when reading two a time for (len - 1) / 2

---- 

The extra newline at the end of errstring appears when the final strtoul
iteration ends with:
} else if ('\0' != *end) {

Basically, we get that conditional when strlen(num_str) is odd (ignoring the
null terminator). So, I think the newline is coming with the input line, from
stdin.

I thought I'd avoided this in main() by checking if the last character in the
line was '\n' and decrementing the line_len. The line_len is returned by
getline() and does not count the null terminator, according to man. But it seems
this does not work.

And do we want this "to work"? Or should we just show the failure caused by the
malformed input? Don't read minds!

Try:
$ echo yo | ./randomart
$ echo yoo | ./randomart
$ echo yoo | tr -d '\n' | ./randomart
